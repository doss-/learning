scripts start from instruction which interpreter to use, first line always must
be the directive. Except if script is passed as param into interpreter, then
there is no need in that because there already an interpreter in place.
#!/path/to/interpreter
i.e.:
#!/bin/bash

Naming Coventions:
    Variable Names: Lower-case, with underscores to separate words. Ex: my_variable_name
    Constants and Environment Variable Names: All caps, separated with underscores, declared at the top of the file. Ex: MY_CONSTANT
    Google naming convetions: 
	https://google.github.io/styleguide/shell.xml#Naming_Conventions

variables:
  Initializate variable by = sign w/o leading or trailing spaces
  Accessing variable by $
  To preserve spaces and stuff use quotas with string vars initialization
   example:
  my_str_var="string w/ spaces goes in quotas"
  echo "stuff is: $my_str_var" > stuff is: string w/ spa.....
  echo 'stuff is: $my_str_var' > stuff is: $my_str_var

if:
  Condition tests in IF should be inside square brackets - [], which are just a
  reference for commant 'test'. see MAN page for TEST for details.
   example:
  if [ 100 -eq ]; then - semicolon is needed in case of single line w/o /n
   -or-
  if [ <some test> ] && [ <other test> ] || [ <yet again test> ]
  then
    <commands>
  elif [ <some test> ]
  then
    <different commands>
  else
    <other commands>
  fi

  lots info here:
  https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php

test:
   test 100 -eq 100 - test whether 100 equals 100
  or [<thing to test>]
   if [ 100 -eq 100 ]
  used to test conditions

  Operator 	Description
  ! EXPRESSION 	The EXPRESSION is false.
  -n STRING 	The length of STRING is greater than zero.
  -z STRING 	The lengh of STRING is zero (ie it is empty).
  STRING1 = STRING2 	STRING1 is equal to STRING2
  STRING1 != STRING2 	STRING1 is not equal to STRING2
  INTEGER1 -eq INTEGER2 	INTEGER1 is numerically equal to INTEGER2
  INTEGER1 -gt INTEGER2 	INTEGER1 is numerically greater than INTEGER2
  INTEGER1 -lt INTEGER2 	INTEGER1 is numerically less than INTEGER2
  -d FILE 	FILE exists and is a directory.
  -e FILE 	FILE exists.
  -r FILE 	FILE exists and the read permission is granted.
  -s FILE 	FILE exists and it's size is greater than zero (ie. not empty).
  -w FILE 	FILE exists and the write permission is granted.
  -x FILE 	FILE exists and the execute permission is granted.
!  NOTE:
  = - does a string comparision
  -eq - does numerical comparison

Loops:
for:
  foreach basically
    example:
  FOR object IN collection; DO command; DONE
   -or-
  for i in 1 2 3
  do
    echo "print $i" > print 1   print 2    print 3
  done

  object - custom name as in regular foreach
  collection - is a collection, could be just 1 2 3 4 
  do and done are the braces

while:
  infinity loop while control is true
    example:
  while read host ...; do... - or like this if in 1 line
  do
    ping -c 3 $host
  done < myhosts.txt

  will read from myhosts.txt while there are lines, each line will reinit $host
  
exit code:
  bash scripts ALWAYS returns exit code.
  to manually return exit code:
  exit nnn - to return nnn
	!!   nnn - MUST be an INTEGER in range 0-255 !!
  exit $? or exit or omitting the 'exit':
   with no params exit code is taken from latest command executed in the script
    Exit code values:
  0-255 allowed
    By convetion
  0 - OK
  1-255 - various errors 

  to test Exit Code:
  echo $? - will return exit code of previous command or value of previously
	    executed script 
  more reading:
  http://tldp.org/LDP/abs/html/exit-status.html

incrementation: increment: i++:
  counter_var=0
  counter_var=$(( $counter_var + 1 ))
