scripts start from instruction which interpreter to use, first line always must
be the directive. Except if script is passed as param into interpreter, then
there is no need in that because there already an interpreter in place.
#!/path/to/interpreter
i.e.:
#!/bin/bash

Naming Coventions:
    Variable Names: Lower-case, with underscores to separate words. Ex: my_variable_name
    Constants and Environment Variable Names: All caps, separated with underscores, declared at the top of the file. Ex: MY_CONSTANT
    Google naming convetions: 
	https://google.github.io/styleguide/shell.xml#Naming_Conventions

execution:
  bash searches for entered command in 
   1. built-ins
   2. hashes
   3. bash history 
   4. env var PATH

  So if script/binary is executed from some(i.e. current) directory and it is
  not in path , it have to be 'source'd like:
   source scriptname
  or:
   . scriptname - . is same to source
  or:
   ./scriptname - this seems to be <current dir>/scriptname (so basically full 
  path, which is also applies)

expansion:
  expansion works before pass anything further, so:
   cp * /some/dir - will copy everything from current dir into /some/dir
  first argument * actually will be passed to cp as list of files matched 
  by wildcard, 'cp' will never see * itself
   variables expansion:
  Expansion starts when $ is encountered. To escape it use
  \ - will escape 1 symbol to treat it as lyteral and not meta symbol
  '' - everything between single quotes threated as lyterals too
  "" - will expand variables, but escape spaces etc.
   Variables are expanded before passing them to command so command will only
  see var's value, not its name.
   Bash creates variable when first mets it, so it will create even empty
  variables, which could lead to errors:
   foo="/some/file"
   mv $foo $foo1  - error
   Bash will create $foo1 variable , then mv will receive $foo1 value which
  is null, and 'mv /some/file <null>' will get error as only 1 param is passed
   To rename file to 'some/file1' use {}:
   mv $foo {$foo}1
   

variables:
  AKA Global Variables - are visible everywhere in shell environment
   if 'export'ed - will be visible in subshells created from the shell
   'local' variables are local for funcions - see below
  is converted to 'String' class by default
  Initializate variable by = sign w/o leading or trailing spaces
  Access variable by $
   Also could be int, if used with 'declare':
  declare -i variable=1
   COuld be readonly:
  declare -r READONLY="this is constant, in uppercase by convention"
   Variables definitions:
  a=z		- assign string "z" to var 'a'
  b="a string"	- assign "a string" w/ space to var 'b'
  c="a string and $b" - expansion works in "" so 'c' value 
			is "a string and a string"
  d=$(ls -l foo.txt)  - result of command is assigned to 'd'
  e=$((5 * 7)) 	- result of ariphmetic result is assigned to 'e'
  f="\t\tastring \n" - escaped sequences also works in "" here:
			\t - tab
			\n - new line
   More than one variable could be declined in 1 line:
  a=5 b="a string" - will create two variables with
		     values "5" and "a string", probably 5 is int.ToString()

  To preserve spaces and stuff use quotas with string vars initialization
   example:
  my_str_var="string w/ spaces goes in quotas"
  echo "stuff is: $my_str_var" > stuff is: string w/ spa.....
  echo 'stuff is: $my_str_var' > stuff is: $my_str_var
   Bash modifiers:
  ${variable:-word} - if 'variable' is set, the result will be its value
	if 'variable' is unset - the result will be 'word'
  ${variable:+word} - if 'variable' is set, the result will be 'word',
	otherwise result will be EMPTY string
  Example:
	$ echo ${variable:-ls} - variable unset - ls used
	> ls
	$ export variable=1
	$ echo ${variable:-ls} - variable is set- its value used
	> 1
	$ echo ${variable:+ls} - variable is set - ls used
	> ls
	$ echo ${variable1:+ls} - variable unset - empty line used
	> 
   Arithmetic expressions syntax $((arithmetics go here)):
  echo $((2+3)) >> 5

local variables:
  local variables are declared in functions, and visible only there
  local variables overwrite globals with the same name
   Syntax:
  local variable_name[=optional_value]
   values are optional , probably, in order to delete some global vars inside
  a function(i.e. vars are used as standard in\out params of a command)
   Example:
  foo=0
  func() {
   local foo
   foo=1
   echo "in func $foo"
  }
  func
  echo "in script $foo"
   Result:
  >in func 1
  >in script 0

here doc here docs here-document here script :
  allows multiline input and it WILL expand even if in ''.
   But will not expand if escaped - \$
   Syntax:
  command << indicator
  text
  indicator

   where:
  command is a command like, 'cat' or anything else (doesn't work with 'echo')
  where text between 'indicators' is expanded by shell and sent to STDIN of
  the command
   Note that also <<- could be used, with it bash will ignore leading
  tabs in 'indicator'
   Note that seconds 'indicator' has to be on separate line and 
  Must have no spaces before or after it, otherwise bash interpreter will 
  conntinue to look for 'indicator' ignoring the one with leading/trailing 
  spaces
   Value of 'indicator' could be any but 'EOF' is preffered

   Example:
  $ foo="text"
  $ cat << _EOF_
  >$foo
  >"$foo"
  >'$foo'
  >\$foo
  >_EOF_
   Result:
  text
  "text"
  'text'
  $foo
   
   Example of use with 'ftp'
  ftp -n << EOF
  open $FTP_SERVER_ADDRESS
  user anonymous username@hostname
  cd $FTP_PATH
  hash
  get $REMOTE_FILE
  exit
  EOF
  ls -l $REMOTE_FILE - will display downloaded from ftp remote file, all the
  	commands are passed from inside the here-document
  

if:
  Condition tests in IF should be inside square brackets - [], which are just a
  reference for commant 'test'. see MAN page for TEST for details.
   example:
  if [ 100 -eq ]; then - semicolon is needed in case of single line w/o /n
   -or-
  if [ <some test> ] && [ <other test> ] || [ <yet again test> ]
  then
    <commands>
  elif [ <some test> ]		# else if, onliner gotta be ; ended
  then
    <different commands>
  else				# one liner gotta be ; ended
    <other commands>
  fi

  lots info here:
  https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php

&& ||:
  allowed inside bash shell logical AND and OR:
   Example:
  mkdir test && cd test
   will create and than change dir to 'test'
  [ -d test ] || mkdir test && cd test
   will check whether 'test' exists, returns 0 or 1
   || continues only if 1 was returned by 'test' and proceeds with mkdir
   && continues only if 0 was returned by 'mkdir' and proceeds with cd

test:
  Tests whether expression returns 0 or not
  after evaluation command 'test' returns 1 if true and 0 if false
   test 100 -eq 100 - test whether 100 equals 100
  or [<thing to test>]
   if [ 100 -eq 100 ]
  used to test conditions

  Logical operators:
   -a - AND
   -o - OR
   ! - NOT
    Example:
  [ ! \( FALSE -o TRUE \)   -- (TRUE) but [ FALSE]
   note the escaped parentheses
   note that 'false' and 'true' command will behave differently , bcs returns
  interegs 1 and 0 respectively

  Requires shell expansion symbols $ 
   Example:
  if [ $num1 -lt $num2 ]; then echo 'int 1 less than int2'; fi

  BEWARE!!!!!!
  shell creates empty variable if it is not defined
  and $num1 -lt $num2 will return TRUE if both undefined

  CHECK YOUR VARIABLES BEFORE USE

   Test Strings\Ints:
  Operator 	Description
  ! EXPRESSION 	The EXPRESSION is false.
  -n STRING 	The length of STRING is greater than zero.
  -z STRING 	The lengh of STRING is zero (ie it is empty).
  STRING1 == STRING2 		STRING1 is equal to STRING2 (= also allowed)
  STRING1 != STRING2 		STRING1 is not equal to STRING2
  STRING1 > STRING2		STRING1 is alphabetically greater than STRING2
  INTEGER1 -eq INTEGER2 	INTEGER1 is numerically equal to INTEGER2
  -ne				integers are not equal
  -le				are less or equal
  -ge				greater or equal
  INTEGER1 -gt INTEGER2 	INTEGER1 is numerically greater than INTEGER2
  INTEGER1 -lt INTEGER2 	INTEGER1 is numerically less than INTEGER2
   
   Test Files:
  FILE -ef FILE1 - both files are hard links (point to same inode)
  FILE -nt FILE1 - FILE newer than FILE1
  FILE -ot FILE1 - FILE older than FILE1
  -e FILE 	FILE exists.
  -f FILE 	FILE exists and is file
  -s FILE 	FILE exists and its size greater than 0
  -L FILE 	exists and is soft symblic link
  -d FILE 	FILE exists and is a directory.
  -b FILE	exists and is Block device (i.e /dev/sda1)
  -c FILE 	exists and char device
  -r FILE 	FILE exists and the read permission is granted.
  -s FILE 	FILE exists and it's size is greater than zero (ie. not empty).
  -w FILE 	FILE exists and the write permission is granted.
  -x FILE 	FILE exists and the execute permission is granted.
  -G FILE 	exists and file belongs to existing group
  -O FILE 	exists and belongs to existing user
  
   NOTE:
  == - does a string comparision
  -eq - does numerical comparison
  
   Escaping:
  symbols < > ( ) need to be escabed by \ or be between ''
  because [ ] is just command test, and bash will try to use them as its own 
  meta symbols (< > are stdout\in redirecton, so could be a MESS)


[[ ]]:
  improved 'test' command but not POSIX compatible
    Differences\Features:

    Does not need expansion symbol $, expands just fine w/o it
   UNLESS IS A STRING, then use "$VAR", to expand and prevent empty values
    Example:
   $ if [[ $num1 -lt num2 ]]; then echo "$num1 less than $num2"; fi
   > 1 less than 2
    NOTE:
   $num1 and num2 are both fine as per expansion works in some other way
   
   BEWARE OF UNDEFINED VARIABLES
   IF BOTH ARE UNDEFINED 0 WILL BE RETURNED!!

    Can compare regex. 
   Seems like gotta match full line, not just some part.
   uses Extended Regex (ERE)
    Requires $ symbol to expand variable value
    use "" to prevent empty values
   No need to escape bash meta symbols like \ or *
    Example:
   $ if [[ "$string_var" =~ \w+? ]]; then echo "good"; fi
   > good

    Can use wildcards , or similar to it..
   When using == equation
    Example:
   $ FILE=foo.txt
   $ if [[ $FILE == foo.* ]]; then echo "matches pattern"; fi
   > matches pattern

   Logical operators:
   && - AND
   || - OR
   ! - NOT
    Example:
   if [[ ! ( FALSE || TRUE )]]; --- in (will be TRUE) but ! will invert to FALSE
    Note that 'false' and 'true' are not commands, commands return 1 and 0
   and behavios incorrectly


(( )):
  Permits Arithmetic expansion and Evaluation for 
  Works only with Integers (no float dot like in Double or Float types)
   Note:
  bash syntax part, not a command
  also does expansion w/o $ symbol before var name

  Arithmetic expansion examples
   a=$(( 5 + 3 )) or a=$((5+3)) - assign result of addition to variable 'a'
   C style manipulations:
   (( var++ )) or $(( var++ )) or ((var++)) - display then increment by 1
   (( ++var ))  - increment by 1 then display
   (( --var ))  - same manner decrement
   (( var-- ))  - display then decrement
   Assignment:
   $((b+=a)) - add 'a' to 'b' and assign result to 'b' - b=$a+$b

   Evaluation:
   if ((10>=5)); then echo "10 greater or equal 5"; fi
      ((var1>=var5))  - same byt with variables
  
  Logical operators:
   same as in [[ ]] - && , || , !

  (()) returns 'true' if integer inside of it greater than 0
   Example:
  dos:bash$ if ((1)); then echo "true"; fi
  >true
  dos:bash$ if ((0)); then echo "true"; fi
  dos:bash$

  


Loops:
for:
  foreach basically
    example:
  FOR object IN collection; DO command; DONE
   -or-
  for i in 1 2 3
  do
    echo "print $i" > print 1   print 2    print 3
  done

  object - custom name as in regular foreach
  collection - is a collection, could be just 1 2 3 4 
  do and done are the braces

while:
  infinity loop while control is true
    example:
  while read host ...; do... - or like this if in 1 line
  do
    ping -c 3 $host
  done < myhosts.txt

  will read from myhosts.txt while there are lines, each line will reinit $host

exit status:  
exit code:
  bash scripts ALWAYS returns exit code. 'exit' is optional
  commands ALWAYS return exit code too. 
  Functions ALWAYS return exit code too. 'return' is optional
  seems like everything returns exit code.
  Even bash shell 'exit'ed with number will return this number
  to manually return exit code:
  exit nnn - to return nnn
	!!   nnn - MUST be an INTEGER in range 0-255 !!
  return nnn - to return nnn but from Function
  exit $? or exit or omitting the 'exit':
   with no params exit code is taken from latest command executed in the script
    Exit code values:
  0-255 allowed
    By convetion
  0 - OK
  1-255 - various errors 

  to test Exit Code:
  echo $? - will return exit code of previous command or value of previously
	    executed script 
  more reading:
  http://tldp.org/LDP/abs/html/exit-status.html

true:
  command that always return 0
   Example:
  exit $(true)   - will return 0 exit code
   or Function:
  return $(true) - will return 0 after Function
   or:
  true   	 - will return 0 exit code
   or Funcion:
  test() {
   true
  }
  test 		 - this will return 0 in script, and if last line - script
		   will return this same 0 to caller (i.e. bash shell)
   Same works for False

false: 
  command that always return 1

incrementation: increment: i++:
  counter_var=0
  counter_var=$(( $counter_var + 1 ))

help:
  lists all built-in commands
   help <built-in command>
  will return help for that command

shopt:
  SHell OPTions - built-in command to set\view shell options

shell types
  See details:
  https://unix.stackexchange.com/questions/129143/what-is-the-purpose-of-bashrc-and-how-does-it-work
  Even more detailed:
  https://askubuntu.com/questions/879364/differentiate-interactive-login-and-non-interactive-non-login-shell
 there are 4 shell types
  Interactive Login shell
    either shell opened via SSH
    or via ctrl+alt+F1(-F6)
  Interactive Non-Login shell
    Opening terminal
    executing 'bash'
  Non-interactive Non-Login
    scripts execution
    or 'bash -c'
  Non-interactive Login
    rare stuff, complex.. should be ssh launched w/o command and STDIN of the
    ssh should has no TTY - echo command | ssh server
    or 'bash -l -c command'

  How to check which shell is:
   echo $-
     if output has 'i' - its Interactive:
   >himBH
   ----
   bash -c 'echo $-'
   > hBc
     NOTE: that double quotes - bash -c "echo $-" still will start interactive
	shell.. probably due to Shell Expansion of variables

   shopt login_shell
   >login_shell off
    will mean that it is NOT login shell
   >login_shell on
    will mean that is IS login shell
 
 Example for each type:
## Interactive, non-login shell. Regular terminal
$ echo $-; shopt login_shell
himBHs
login_shell     off

## Interactive login shell
$ bash -l
$ echo $-; shopt login_shell
himBHs
login_shell     on

## Non-interactive, non-login shell
$ ssh localhost 'echo $-; shopt login_shell'
hBc
login_shell     off

## Non-interactive login shell
$ echo 'echo $-; shopt login_shell' | ssh localhost
Pseudo-terminal will not be allocated because stdin is not a terminal.
hBs
login_shell     on    

functions:
  shell could have functions, funcions MUST BE declared before its call,
  otherwise shell will interpret funcion names as regular commands
   Functions could be executed and calld from shell, added to scripts or 
  bashrc/profile files so will be available in cmd as regular command
  'return' command in optional
   Function MUST has at least one command, in order to mock\stab 'return'
  command could be used.

   Syntax:
  function name {
    <commands>
    return
  }
   Or equivalent:
  name() {
   <commands>
   return
  }

    Example:
  script.sh:
  function func {
   echo "step 2"
   return
  }
  echo "step 1"
  func
  echo "step 3"
  
   Result:
  >step 1
  >step 2
  >ste 3

   Example .bashrc:
  ds() {
   echo "disk space utilization for $HOSTNAME"
   df -h
  }

   Result after shell restarted 
   (after source .bashrc ds looped and crashed shell):
  $ ds
  > disk space utili....
  > ...output of df -h....
  
