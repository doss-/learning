# [Gianluca Abezzano] DevOps never sleeps. What we learned from influxDB v1 to v2

![Intro](img/devops_conf_2019/IMG_20190406_095955.jpg)

Docker is pretty layered system, which is split even more recently after ContainerD is moved into OpenSource by Docker development team.

The layers if Docker infrastructure are:

1. CLI
> command line interface for accessing Docker daemon  
2. REST
> restfull interface for accessing daemon. TODO: check whether CLI also uses it
3. dockerd
> docker service that accepts CLI and REST  calls and translates them further tocontainerd service(daemon)  
  [Docker Engine](https://docs.docker.com/engine/docker-overview/#docker-engine)
4. containerd
> service that is moved into separate project. main purpose is to made this _Core_ service to be fully crossplatform. 
containerd daemon exposes its API that is  used by dockerd and others parties interested in communication witn containerd in order to use services it provides.
It is currently used everywhere where containers and docker are  used - AWS, Azure and all the cloud providers that adopted docker as engine for containerization. 
Also this is the core that runs on multiple OS such as: Linux, MacOS, Windows etc.  
5. RunC
> __TODO: write RunC description, and probably add more layers..__

__TODO: which of above uses Linux Socket\TCP Socket in order of communication with outer world.__

## Jenkins and k8s

Main point in usage of docker infrastructure by '3rd parties' is in acquiring access to docker socket.  
It could be illustrated by starting docker container with docker(sub) running inside it.  
Sub docker could manipulate parent docker if it has access to parent docker's socker, for instance by mounting socket file to sub docker's container:  

    docker run -v /var/run/docker.sock:/var/run/docker.sock -ti docker bash


in this example docker socket is passed from Host system into the container so docker running in the container could manipulate Host's one.

This is  how Jenkins plugin and k8s work.


## Tracing and effective logs monitoring

In order to trace different important events out of all the system information, unimportant warnings and errors information need to be correctly logged, aggregated and filtered.  
Metrics need to be used and calculated, and tracking of events throught different logs need to be applied to that. 

After all the logs are gathered, together with metrics and tracking applied to it, some particular thing could be Traced.

Metrics alone is just like slap to the face, it is sudden and only  has shock effect.

Logs in raw view are useless, the sence comes after aggregation and ability to filter it.


### State of the system.

Monitoring of the system could be done by monitoring its State:

- Hardware charasteritsitcs like CPU usage
- processes rununing and resource usage
- I\O activities 
- etc

But just snapshot is usually not enough.   
Like 'ps -lte' - it could return actual and correct info but it will not gave any meaningful info in order which process works ineffectively or wrong.  
For more efficient monitoring 'top' program will give much more info about processes and how they are utilizing system's resources.  
But this gives realtime results and requres constant attention, it order to find which process does what.  
So for effective monitor we need a tool that will save changes into history and ability to filter and even visualize the history.


But w/o any context even atual, filtered and visualized info makes no sence:

> __Normal State.__

When everything in the system runs OK, and everybody is satisfied we could call it the Normal State of the system.  
This state need to be saved with all the metrics calculated and attached, to be used later when need to determine how system works at given point of time.

> __Current State__

At any point of time we could apply all the filters to logs, calculate metrics and visualize statistics (even of some time period). This will give us the Current State.  
Comparing this _Current State_ with a 'golden standard' like _Normal State_ will give the answer to the main question:  
 _Whether everything is fine with our system Now?_


## Design applications correctly in order to monitor them later

In order to monitor system state effectively we need the info in first place.  
Info is the logs generated by apps which state we want to monitor.  

When Application is developed logs generation should be keep in mind. In ideal way app should has API to access logging functionality from outside by other systems: 

    [App [[Logs func + stuff ] API for logs access\creation]]

in that way some logs\events storage facility could use API to ask app for some particular logs an particular point of time.

### Code Instrumentation (hello Bullseye)

Existing code  also could be instrumented (i.e. during compilation)

Later on during runtime this added parts will fire and write logs\events somewhere ( i.e. into some stream). Also this added part could provide API access for other tools.  

### Tools \ Links


- ELK(B)
- Prometheus(google)
- [Jaeger](https://www.jaegertracing.io/)
- bullseye. not related to article, just example
- OpenCensus(google\open source)
- [mount-bind docker socket](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)

![Summary](img/devops_conf_2019/IMG_20190406_104105.jpg)

# [Philipp Krenn - Elastic] Hands-On ModSecurity and Logging

Basically this talk is about security breaches that could be logged and monitored uneffectively, thus alerting user too late and with lack of general information.  
Tool that is demonstrated in order to prevent both breaches and bad monitoring is ModSecurity

### Security issues

![the guy](img/devops_conf_2019/IMG_20190406_111121.jpg)  
[the link](https://www.owasp.org/index.php/Top_10-2017_Top_10)

There could be gaps in app with security

Gaps could be covered outside the app with tools, that filter out traffic analizing its inner parts, like requests (i.e. request having 'update' sql directive will be filtered out in some case, and 'delete' almost everytime)

Some traffic could be sniffed by the [ModSecurity](https://en.wikipedia.org/wiki/ModSecurity), and it will make a decision of what to do , whether block traffic completely (nevertheless notifying the logs 
) or just log info\warning\error.  

> ModSecurity is an __open source__, __cross-platform__ web application firewall(WAF) module.

> It enables web pplication defenders to gain visibility into HTTP(S) traffic and provides a power __rules language__ and __API__ to implement advanced protections.

So in case ModSec decided that traffic package has some malwarish things this request to the web server could be blocked preventing anything from happening and end user will get 503 error or something similar to it

### Logging an monitoring issues

The app itself could write logs, the instrumented app could write logs, and even apps running atof of main app could add logging

Logs are generated by ModSecutiry, then are gathered by  File Beat and fed into Logstash, which applies filters to match particular fields of the log to be filtered by or displayed in Kibana.  

Basically after ModSecurity is turned on and set up, it generates logs which could be viewed in ELK, containing all the info from where package came from, when, what it had, and in general full statistics could be gathered to understand whole picture.

> __Logs Enreachment__

Like taking IP from the logs and adding where it is from (country) to add meaning and context fo the logged info, w/o which it is pretty useless.  

### Tools \ Links

- [Elastic Stack: Beats](https://www.elastic.co/products/beats)
- [Sqlmap](http://sqlmap.org/) - tool to check website db for various vulnurabilities  
- [ModSecurity](https://modsecurity.org/)  
- [ModSecurity & Logging demo](https://github.com/xeraa/mod_security-log)  
> terraform+ansible+aws+apache+modsecurity
- [presentation](https://speakerdeck.com/xeraa/hands-on-modsecurity-and-logging) local place: img/devops\_conf\_2019/presentations/ModSecLogging.pdf

![Examples link](img/devops_conf_2019/IMG_20190406_114517.jpg)

# [Nikita Procenko - Netflix] Infrastructure-as-code: bringing the gap between Devs and Ops

the talk mostly about approaches, and terraform:

## Immutability of infrastructure  

TODO: write down about immutability - easier to recreate instancec than patch it, to avoid regression and stuff

## Declarative vs Imperative

__Imperative__ approach is when everything is explicitly designed. This is the list of detailed instructions of HOW TO do something.  
> bash, aws cli

__Declarative__ on the other hand is abstract form where only END STATE is given. Basically Declarative approah is just a wrapper around Imperative code. Imperative part here is incapsulated out of sight of regular user.  
Take Ansible - the only user do is state that Foo program need to be on the system. And Ansible will ensure it - install, update, or do nothing if Foo already existts.  
> terraform, ansible

Example:

Imperative C#:
    
    List<int> collection = new List<int> { 1, 2, 3, 4, 5 };

    # Imperative: get only Odd numbers
    List<int> results = new List<int>();
    foreach(var num in collection)
    {
        if (num % 2 != 0)
              results.Add(num);
    }

    # The code below has detailed instructions of what to do step-by-step

    # Declarative: get only Odd numbers  
    var results = collection.Where( num => num % 2 != 0);

    # or even more Declarative:
    from item in collection where item%2 != 0 select item

> declarative vs imperative is more about _declaring what you want to have_ happen vs. explaining exactly _how it needs to occur_.

Terraform, the same as Ansible are the higher level abstraction tools that are Declarative.  
The user only declares what he wants - tool inistalled or EC2 Instance created from specific image within specific subnet with a specific name etc. and the Tool will ensure for the User that this happened.

Bash scripts on the other hand are Imperative.   
Where everything is explicitly and in a detailed way is explained to the interpreter which will go step by step doing what it is told, and at the and we need to ensure that everything is in place as we Wanted it.

[read more](https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-programming)

## IaC Demo:

https://github.com/iac-demo

-------------

Other at all:

[tech interview presentation](https://speakerdeck.com/jacobian/how-to-ace-a-technical-interview?slide=11) starting #10 slide
