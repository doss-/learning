===General
Docker is Client-Server app, both could be run on the same system or client 
could be connected to a remove Docker Daemon

Docker Clients and Servers communicate through sockets or RESTful API
(Representational State Transfer - stateless transfer over HTTP of a web page 
containing XML file that describes and includes the desired content)

Docker main components are:
-Daemon
-Clien
-Docker.io Registry

=====Virtualization General
Typically Regular Virtual machine needs Hypervisor - the software that will 
allocate and communicate hardware resources of the server to the Guest machines
Two tipes of Hypervisors:
 Type1 - where there is no OS on the server and its functions takes Hypervisor,
which manages Guests
 Type2 - server has an OS and OS has a Hypervisor and Hypervisor manages 
resources for Guests

Docker shares Host operating system, and ask for resources through it
Also because of sharing it does not need whole Guest OS, only libs that is
required for particular application, or to emulate different OS used in the
Container.
Additionally because it does not need to boot by itself, Container may lack
lots of unused binaries so it is lightweight and fast. 
It could use Linux OS which is prepared for Flash\CD boot and it will be even
more lightwieght and fast


===Installation
install

Centos7
  add docker repo 
   into /etc/yum.repos.d (see linux_cheatsheet for details)
    file named <anything>.repo, containing following:
	[dockerrepo]
	name=Docker Repository
	baseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/
	enabled=1
	gpgcheck=1
	gpgkey=https://yum.dockerproject.org/gpg
  update yum
   yum update (see linux_cheatsheet for details about update)
  install docker-engine package
   yum install docker-engine
  start service 'docker'
   systemctl enable docker
   systemctl start docker

  make sure it works:
   systemctl status docker
   docker --version
   sudo docker images - docker client installed together with docker server
	is able to connect to the server and fetch list of images

  Regular user:
   Docker uses docker.sock socket to connect to server, this socket is 
   represented as a file(as everything in linux) and is located in:
    /ver/run/docker.sock
   this file is owned by user 'root' and group 'docker', both user and group
   have same permissions 'rw-'.
    So to be able to run Docker commands which will require Server connection
   as a regular user, this user need to be added to 'docker' group

===General
Base image:
  pull from Docker Hub or another private repos not in Docker Hub.
  Base image is the image we  pulled from somewhere and could build upon it our
  own image.

Container Lifecycle:
  Pull - Image is built or pulled from repo
  Run - image is run and container is instantiated
    Network interface for docker server is used to connect to particular 
    container which is given IP by Dockers DHCP

/var/lib/docker - man working dir of Docker
  .../container - has containers. each directory name is the container name
	returned by 'docker ps -a' command
 /var/lib/docker/image/overlay/imagedb/content/sha256 - where 'overlay' is a
	storage driver name. This will contain all the Images, names will be
	match with Image ID returned by 'docker images' command

IP address
During install docker daemon creates its own Network Interfacte, with ip address
attached, like 172.17.0.1. 
New containers will be assigned addresses from this pull, from ..0.2 to 0.254

man:
  regular 'man' command works with Docker in the following way:
   man docker - will cal manual for Docker
   man docker-run - will cal manual for 'docker run' command
	So to call man need to substitute spaces with dashes, it should work for most of the commands

version:
  command that displays pretty detailed version info about all the docker stuff
  Client, Server, their Go version, API, built date for both etc.

--version
  parameter for 'docker' itself. 
  Displays version of the docker and its build hash

info:
  command that returns lots of information about Docker engine

images:
  displays list of locally available images
  format
   REPOSITORY - name of repo where downloaded, seems like name of image too
   TAG - tag, 'latest' or other, like version number
   IMAGE ID - id of the image
   CREATED - when it was created in the repo(not pulled locally)
   SIZE - size of the image

pull:
  pulls image from a repo
   docker pull [repo/]<image>
  default - latest version
  version could be specified by tag:
   docker pull centos:centos6 - will pull version 6, when 7 is latest one
	'centos6' is a tag, which specifies a version number
   docker pull centos - will pull using default tag 'latest'

search:
  searches for an image in a repo(somewhere configured)
  Search results has Name , Description, also as
   Reputation - STARS, which is some kind of carma?
   OFFICIAL - official repo marked [OK]
   AUTOMATED - dunno, but marked [OK] if yes

  docker search centos - will search for image containing word 'centos' in its
	name(and probably description)

network:
   network drivers are configured via JSON config files, usually there are:
	bridge - main network, all other networks goes through here, DHCP is configured according to it, and range of IP addresses also
		configured here
	host - TODO
	none - TODO
  ls:
   lists all the network interfaces\drivers available for docker daemon
  inspect: 
   inspect <networkID\Name> - lists all the settings of given network, like inspect <container>, including IP ranges(Subnet), Gateway etc.
	i.e. com.docker.network.bridge.name, looks like is what is displayed in 'ifconfig' for its network interface
  create:
   creates a network, that could be listed by 'network ls' command
	Example:
   docker network create --subnet 10.1.0.0./24 --gateway 10.1.0.1 mybridge01 - will create new network of type 'bridge', probably default one
	all other stuff will be default(as well as driver used). this network will be available for view by 'docker network ls'
	Also it will be seen in 'ifconfig' as a regular network interface, with wierd name(beginning of network ID actuallybeginning of 
	network ID actually)
  rm:
   remove network. by ID or Name
	!!!! DO NOT REMOVE DEFAULT NETWORKS, it will probably lead to whole Docker reinstallation. !!!!
    Example:
	docker network rm mybridge01 - will return network name and delete it

run:
  runs a image thus creating a container
  docker run [params] <image> [command to start with] [params to the command]
   can run by Image name - 'REPOSITORY' field in 'images', by ID 'IMAGE ID' 
   field or by container name. 
   Container name could be manually or automatically assigned, then it will be 
   bound to the container and this exact container could be restarted.
  -i - interactive run
  -t - connect tty to current terminal
   Example: 
    docker run -it centos:latest /bin/bash
  -d - detached, container will run in background
  --name=<name> - creates container with specified and not random name
  -P - auto publishing. of all exposed Container's ports. Assigning random port
	number (range defined by /proc/sys/net/ipv4/ip_local_port_range) for
	every exposed port
	Forward == Publish
  -p=[] - publish specified port, or range of ports. If range is used amount of
	ports should match each other:
	 -p 1234-1236:1234-1236/tcp - 3 ports on the left(host), 3 ports on the
	right
	 -p 8080:80 - publishes port 8080 on Host to port 80 on Container
	also could bound IP, like
	0.0.0.0:80:172.17.0.2 - 0.0.0.0 means any IP from Host network interface
	is fine.
	Which means traffic for port 80 coming to any Host ip(127.0.0.1 or any 
	other) will be forwarded into container
	 docker run -d -p 80:80 nginx - will run nginx in Detached mode with
	port 80 of container is published as port 80 of the host
  Volumes can not be made in Dockerfile because Dockerfile meant to be 
	portable
  -v /host/dir:/container/dir - mounts a Volume from Host machine into Docker
	container. It could overwrite Docker directory, like /etc or default
	nginx dir for stuff to display.
   --volume /mydirectory - will create directory 'mydirectory' as a volume
	inside the container. Thus this will be destination
	Using 'docker inspect' source could and it will be:
	/var/docker/volumes/<ID>/_data
  --mount - is the recommended way to use volumes. see '--mount' here:
	https://docs.docker.com/engine/reference/commandline/service_create/#add-bind-mounts-volumes-or-memory-filesystems
	

  --entrypoint - overides entrypoint of the Base Image

stop:
  stops the container
   docker stop <name>

ps:
  process list from withing docker daemon
  returns all running containers
  docker ps
  -a - returns All containers, including those who stopped already
  -q - returns only hex IDs of the containers

inspect:
  gives info about local image or container(running or stopped), output is in 
  JSON format.
   It gives much more information if Running Container is inspected, such as
  IP address etc
 
  docker inspect nginx - will show info about local image of 'nginx' in JSON
	such as info about container config - its hostname, user, STD* 
	processing, tags, env variables set for the container
	env vars will be inherited in case of building on this image

attach:
  docker attach <container>
  attach to containers process, the main process given to it by Dockerfile.
  Exiting after attach will stop the container, because its main process was
  stopped.
  Useful only if some shell (i.e. bash) is executed there. i.e. if this is nginx
  container no command promt will be given.

  SO in case of Nginx, attaching to container will attach to the Process.
  And exiting by ctrl+c or 'exit' will effectively stop Nginx, and thus a 
  container too.
  

exec:
  execute something on a container that is running some other process and
  'attach' wont help.
  Exiting by 'exit' or ctrl+c will not stop the container as per it is still 
  running its main task given to it in Dockerfile.
  exec <new process> <container>
   Example:
  docker exec -it LifeCycle1 /bin/bash - will execute /bin/bash on container
	LifeCycle1 which is running Nginx in detached(-d) mode and can not be
	attached in useful way
	Notice '-it' params which are the same as for Run command
  -u <UID> - use specific user id during exec execution,
	UID 0 - will be ROOT id (see /etc/passwd for UID)
	docker exec -u 0 -it container_name /bin/bash - will connect to 
	'container name' as Root, regardless which user is specified in USER 
	directive in the Dockerfile
 
start:
  starts previously stopped container(which could be found by 'ps -a')
  start <container>

restart:
  Shuts down and Starts the container.
   IF the process is restartable
 
stop:
  stop <container>
  gracefully stops the container

rmi:
  removes image by its name ID or repo + tag
  docker rmi <repo:tag>
  It will untag and delete image
  Images that has container instatiated from it(even stopped) will not be 
  deleted without Force. 
  Or containers need to be deleted first (see rm command)
   Example:
  docker rmi centos:centos6 - will remove image from repo 'centos 'tagged as 
	'centos6' which is basically its version

rm:
  removes container by its ID or name
   docker rm <name or ID> [name or ID]
  -v - delete any volumes associated with a container
    Example:
  docker rm name1 name2 - will remove containers named name1 and name2 from 
  the system

  ` - back tick(tilda button w/o shift) allows to execute command and put its 
	results out one by one to parent command.
	Actually it will execute another shell with commant between ``. 
	Same as in For loop like 'for i in `ls -la .`'

  xargs is used for piping:
   docker ps -a -q | xargs docker rm - will display all IDs of all the 
   containers and send it to xargs through pope to rm command.
  Same w/o xargs:
   docker rm `docker ps -a -q`
  Another solution:
   docker rm $(docker ps -a -q)

  -f / --filter "key=value" - filters ps output by key-value paris:
    docker ps -a -f "name=name" - will print out all the containers(stopped and
	running) which field NAME contains string 'name'

port:
  displays all the ports of container and their mapping
    docker port <ContainerName\ID>
  output displays which port under which protocol is exposed on Container
  and the way it is published on the Host(IP of the host and Host's port which
  forwards traffic into COntainer's port)

container port:
  does the same as port, but inherited from 'container' command
    docker container port <Container\ID>

commit:
  commits container into the docker hub repo as an image
  commit is done into local repo, same as git
   docker commit -m "commit" -a "author" <container_name> <user/repo:tag>
  -m "comment" - commit, same as for git
  -a "author" - author name or email, something like this
  
build:
  builds an image from a Dockerfile
   docker build -t="user/imagename:tag" .
  -t - tagged image
  . - use current directory and search for Dockerfile
  or instead of . use:
  < /path/to/Dockerfile
  
logs:
  returns logs of the container. Available only with 'json-file' and 'journald'
  logging drivers.
   docker logs [params] <container>
  --follow - will do pretty similar as 'tail -f'
  --timestamps - will add timestamps
  --details - will add more to the logs, such as env vars etc.
  --since - will show only logs since some date:
	1m30s, 3h - Go duration format
	2006-01-02T15:04:05 - RFC 3339 Nano format
	local time zone is used unless Z or +-00:00 provided

===Dockerfile

FROM
  need to be first command, tells docker daemon from where to build.
  could be:
   scratch - means no image need to be searched or downloaded
	then file need to be added which will contain all the
	needed binaries
   image[:tab] - name of the image optionally with tag, which will be 
	downloaded and used as base image, to which all the other commands
	will be applied

MAINTAINER
  name or email or anything relating of who maintans the image

RUN
  RUN <command>
    RUN useradd -ms /bin/bash testuser
  runs a command after 'RUN ', like regular cli command 'useradd'
  command will be executed\saved as a layer
  Can be executed several times during Dockerfile

CMD
  executes command, but it does not become a layer
  Can be inherited from parent image in FROM directive
  Can be overridden in child docker file using CMD [] directive
   CMD "echo" "this is a test message" - will execute Echo command with a custom
	message. Also container will immediately stop after doing that, if
	no other directives are given for it to run continuously
  
ENTRYPOINT
  Executes a command EVERY time, no matter what command is given during 
  instantiation like 'docker run .... /bin/bash'
  Can be inherited from parent image in FROM directive
  Can be overridden in child docker file (probably)
  or in command line using --entrypoint of docker run command
  Usually shell is executed with this directive

  ETNRYPOINT echo "echoed message" - will be displayed all the time no matter 
	what is applied to run command(such as /bin/bash)
  ENTRYPOINT apachectl "-DFOREGROUND"

  

USER
  USER <username>
  marks entry point for a container to be under specific user.
  in this case user first need to be created using RUN command
   All the commands in Dockerfile after this directive will run under 
  the user that was specified!

Environment variables manupulation:
  the simpliest way is to export something into users .bashrc file:
  RUN echo "export JAVA_HOME=/usr/java/jdk1.8.0/jre" >> /home/user/.bashrc - 
	this will add a line into .bashrc file which is read every time the
	shell is executed. Basically is standard way to add ENV variables for a
	user
ENV
  sets system-wide variables
  ENV <key value>
   ENV JAVA_BIN /user/java/jdk1.8.0/jre/bin

EXPOSE
  exposes particular port, or probably list or range of ports
  This port will be always exposed in the container unless unexposed in some
  manual way
  The same could be achieved with using 'docker run -p' command
   Although '-P' param will not expose anything because it looks for already 
  exposed ports on the containers, and w/o EXPOSE directive there are none
   EXPOSE 80
