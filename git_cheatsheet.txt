Links:
 https://coolaj86.com/articles/vanilla-devops-git-credentials-cheatsheet/
  clone git w/o credentials

Authentication:
  'remote' url need to be 
    git@github.com:<username>/<repo>
     or
    ssh://git@github.com/path/to/repo
   CHECK:
    ssh -T git@github.com
     this will check connection, and great <username> in case of success
     And correct protocol should be used, otherwise will ask for login/pass

Git Data Storage:
  https://www.youtube.com/watch?v=ZKrtHjf5yPQ
  Git has 5 types or objects:
  1. Commit - points to a tree
  2. Tree - is a directory, and points to a blobs
  3. Blob - is a file
  4. Annotated Tag - tag points to particular commit SHA-1
      so it's easier to remember tag than commit HASH
   Objects are stored in .git/objects. Objects dir contains
    hash-named and compressed text files. Name formed as follows:
    2chars/otherChars
    where SHA-1 hash first 2 chars is the Directory and other chars is filename
cat-file:
   Views the contents of Hashnamed object-file:
    Params:
   -t  - returns type
   -p  - pretty prints contents
    Example:
   .git/objects/aa/a524cf75aa4b8baf1be939b39f32a6644a8f2a - is a git object
    To get its type concat dir-name and file-name as a param:
   git cat-file -t aaa524cf75aa4b8baf1be939b39f32a6644a8f2a
    To get contents:
   git cat-file -p aaa524cf75aa4b8baf1be939b39f32a6644a8f2a
Commit Object structure:
  1. Pointer to Parent commits (0 for initial 2+ for Merge commit)
  2. Pointer to Root Tree - Root directory
      it contains pointers and names of root level files(blobs)
         and other directories(trees again)
  3. Author name, email, date
  4. Committer name, email, date
  5. Comment message of the commit
Branch:
  Branch is a pointer to a commit.
  Text file in .git/refs/heads directory, contains only commit hash
  to which it points.
  It points to the latest commit, so moves forward with each commit
   into the given branch.
  'master' is the same branch as others, just a default name after 'git init' 
HEAD:
  points to current branch
  Text file .git/HEAD, has relative path to current branch
  Usually sticks to a branch, then moves forward with commit as 
  well as 'branch' pointer also moves forward.
  If 'tag' is checked out, HEAD points to Tagged commit BUT tag does not moves
   with the head, so commit doesn't belong to any branch and reachable only
   by its SHA-1 hash (search 'git log --all' will not help)
three way merge :
  WHAT IS MERGE BASE 
   this is one of Parent commits, better suited for merge?

   


config:
  configure git account - addresses, user name, email etc.
   --system  - /etc/gitconfig  for all users
   --global  - ~/.gitconfig    for current user
   --local   - .git/config     for current project, default
   --file <file>
  NOTE:
   Git does NOT validate fied names, so CHECK NAMES for PROPERTIES
   misprints in names would not be validated.
   misprinted 'core.eXitor' would be saved instead of core.exitor.
   Synopsys:
  git config [config file] [action] [key value]
   Params:
  -l - list all params
  -e - open editor to edit config file (.git/config)
  --add - add key value pair: key value
   Example:
   git config --global --add user.name doss-
   will add to Global config key 'user.name', with value 'doss-'
  --global / system / local - use different config file, locacl for repo
   Config fields:
  user.name - name of the user 
  user.email - users email, these two fields are used to identify user
   in github
  core.editor - default editor to use
   Example:
  git config core.editor vim
   will add vim for current repo as a 'vim' (full path from PATH prob)
  credential.helper - use credential manager, useful for HTTPS with login\pwd
   Example:
  git config --global credential.helper cache
   will use login\pass cached for few minutes, to not ask user everytime
  remote.pushDefault origin
   default push repository, set as origin

   Email setup: for
  format-patch:
   [imap]
      folder = "[Gmail]/Drafts"
      host = imaps://imap.gmail.com
      user = user@gmail.com
      pass = YX]8g76G_2^sFbd
      port = 993
      sslverify = false
   Example:
  git format-patch -M origin/master
  cat *.patch #or one by one to view anyway
   #If you add text between the --- line and the beginning of the patch
   #(the diff --git line), the developers can read it, but that content is 
   #ignored by the patching process.
  cat *.patch |git imap-send
   At this point, you should be able to go to your Drafts folder, change 
   the To field to the mailing list you’re sending the patch to, possibly 
   CC the maintainer or person responsible for that section, and send it off.
    SMTP:
   [sendemail]
      smtpencryption = tls
      smtpserver = smtp.gmail.com
      smtpuser = user@gmail.com
      smtpserverport = 587
  git format-patch -M origin/master
  git send-email *.patch

clone:
  clones repository locally , later parent repo could be reached as origin
   Params:
  -o/--origin <remote_name> - change 'origin' to custom remote name
   Example:
  git clone -o booyah
   now default remote('origin') would be 'booyah'; booyah/master instead
   of origin/master
   Process under-the-hood:
    creates dir;
    initializes '.git' dir;
    sets 'origin' as remote repo with URL;
    sets 'master' as default remote branch;
    fetches a working copy of latest version;
 Common protocols:
  https: https://git.address.com/project/repository[.git]
  git: git://git.address.com/project/repo.git
  ssh: user@server:path/to/repo.git
       git@github.com:path/to/repo.git
        Note: sometimes username(git) is only one available\acceptable
  Example: clone locally:
 this will allow have repo and working local branch on the same machine
 git clone <username>@localhost:/path/to/repository <local dir name>
  Example:
 git clone https://github.com/libgit2/libgit2 my_libgit2
  clone 'libgit2' repo in 'my_libgit2' directory in pwd

fetch:
  gets all the data from remote repository (by default 'origin' if cloned)
   data includes all files in all branches
  sets remote pointers up to date:
   if origin/master has changed it will now be updated locally to up to date
  does not try to merge anything
  When new remote tracking branch fetched, it is not editable locally
   there is only origin/newbranch pointer, readonly(does not move on commits)
   There is 2 options available:
   - Merge into writable local branch:
     git merge origin/newbranch
   - Create new local branch out of remote branch:
     git checkout -b newbranch origin/newbranch
     git checkout -b custom_newbranch origin/newbranch
      local name could be custom, if need to push back to origin/newbranch:
      git push origin custom_newbranch:newbranch
  --all - fetches all the remotes known
   

pull:
  fetches and merges from remote repo the given branch
  if there is Remote Repo(origin by default) and Remote Branch(origin/master
   Can pull from URL, as a one-time pull - not saved as a remote
   git pull https://github.com/onetimeguy/project [branch]
  by default) 
   Example:
  git pull origin master
   If 'origin' and 'master' are defaults, those could be omitted into
  git pull
   --rebase  - if someone pushed rebased history in remote
       does rebase of remote branch:
    git fetch
    gir rebase <origin>/<tracking_branch>
  --allow-unrelated-histories
     when commits were edited somehow, or could not get it into a tree 
     of dependant commits, this allows to download them
      Error Example:
     refusing to merge unrelated ...
  --verify-signatures - reject commits signed with not Truested GPG 
    Will fail to merge commits Not Signed or Signature is Not Valid
   -S  - sign the resulting merge commit too


request-pull:
  request pull between forks, pull request.
    Example:
   git request pull origin/master my_fork
     Where:
    my_fork - another remote along with origin
     Takes current branch, produce summary between it and origin/master
     Asks origin's maintainer to pull from my_fork/<current_branch>
     into origin/master branch
     

push:
  pushes local commits into Upstream('origin'), or branches, or tags
  if HTTPS is used, git will ask for credentials, see credential.helper 
   git push [remote] [branch|tagname]
  if Cloned, default remote is 'origin', default branch is 'master'
  git config remote.pushDefault origin - set default remote as origin
   Example: 
  git push origin My-New-Branch
   pushes local Ny-New-Branch to the remote with write access
    Under the hood:
   git push origin refs/heads/My-New-Branch:refs/heads/My-New-Branch
     <source_ref_branch\tag>:<target_remote_ref_branch\tag>
    Same as above:
   git push origin My-New-Branch:My-New-Branch - will do the same
    or
   git push origin My-New-Branch:My-Renamed-Branch-On-Remote - push and rename
  Push doesn't push Tags automatically. To push tag do it explicitly:
    Example:
  git push origin v1.0
   will push v1.0 tag to origin remote
  --tags  - pushes all tags to remote , annotated and lightweight together
   Example:
  git push origin --tags
  --delete <branch> - deletes branch from the remote 
   it will hung out some time until garbage collection, so could be
   recovered somehow...
   OUTPUT Example:
  1edee6b..fbff5bc master -> master
  <oldref>..<newref> fromref -> toref
   fromref - local reference being pushed
   toref - remote reference being updated (origin/master)

add:
  "add precisely this content to the next commit"
 uses:
  - begin tracking of new files
  - stage changes in tracked files
  - mark merge-conflicted files as resolved
 Params:
 -i/interactive  - interactive mode
                    HELL of a mode
 -p/patch   - same as [p] in interacitive, but for everython unstaged

 Example:
  git add .
   add everything untracked and changed

status:
  Shows status of current repository:
   - on which branch
   - are there any differences in commits with upstream
     - number of commits ahead\behind
   - staged files (to be committed)
     - both tracked and untracked
   - changed tracked files
   - untracked files

  Params:
   -s/--short  - short form:
    left Column  (Green)  - status of Staging area
    right Column (Red)    - status of Working Tree[Directory]
    ?  -- untracked files
    A  -- new files added to staging
    M  -- Modified AND Staged
     M -- Modified NOT Staged


git reset:
  moves HEAD and Branch(e.g. Master) pointers to previous commit
   Unlike revert it does not create new commit, just moves pointer
  to a previous commit (or any other if specified)
   Read More:
https://www.atlassian.com/git/tutorials/undoing-changes/git-reset

  DESIGNED TO UNDO LOCAL COMMITS

   --hard - moves state of all 3 Git Trees (DANGEROUS)
	Working directory
	Staging area
	Commit history
   --mixed  (default) - moves state of 2 Trees
	Staging area
         It will OVERWRITE Working directory if conflicting changes
	Commit history
          Example:
     git reset HEAD~    -- moves back one commit:
      HEAD~ or HEAD^ means the commit before head 
     git reset <hash of the commmit TO MOVE TO! >
   --soft - moves state only of 1 Tree
	Commit history

   In case of --hard reset all the data will be wiped out
	w/o possibility to restore it
   Mixed reset clears staging area, moving everything from there
	back to Working directory tree, so changes are there and
	not lost
   Soft reset moves only Commit history back, and everything
	that was staged remains staged, and everithing that 
	whas edited but not yet added , remains also

   Example:
     reset foo.py - resets foo.py leaving it only in Working tree

     reset HEAD~2 - moves HEAD back for 2 commits, using --mixed
	flag as default



revert:
  creates new commit which will be added to the history
	_after_ the commit to which user want to revert
  Generally:
  DESIGNED FOR UNDO PUBLIC COMMITS
    Read More:
https://www.atlassian.com/git/tutorials/undoing-changes/git-revert
  Also:
   could unstage hunks of files (see git add -i [r]evert)
  -p/patch  - interactive unstaging of hunks
  


git ls-files:
  debugging util , displays all the files and their hashes
	if file has been moved from Working to Stage the
	hash will change

   -s  - stage, displays only staged stuff

git rm - removes files, adds to staging area
  -r - recursivelly
  --cached - removes from index (but need to confirm 
   wtf it does)

git mv - rename/move files , adds to staging area


.gitignore:
 Seems like it applies right after file save, why did i
think i need to commit it first? weird
   Examples:
    github.com/doss-/learning/.gitignore
    github.com/github/gitignore
  Rules:
 - applies to children dirs (and current dir)
 - blank lines ignored
 - line starts from # ignored - comment
 - globs are applied recursively throughtout entire working tree
    globs are simplified regex (like in shell):
     * - zero or more chars
     [abc] - any char in braces i.e. a or b or c
     ? - single char
     [0-9] - range from 0 to 9
     ** - match nested directories (any number)
       Example:
      a/**/z - a/z; a/b/z; a/b/c/z
 - line starts from / disables Recurse
 - line ends with / marks a directory
 - line starts from ! is exclusion (un-exclusion)
   exclusion rules:
    to uninclude subdirectories see this https://stackoverflow.com/questions/5533050/gitignore-exclude-folder-but-include-specific-subfolder
    The pattern dir/ excludes a directory named dir and (implicitly) everything under it. With dir/, Git will never look at anything under dir, and thus will never apply any of the “un-exclude” patterns to anything under dir.
    The pattern dir/* says nothing about dir itself; it just excludes everything under dir. With dir/*, Git will process the direct contents of dir, giving other patterns a chance to “un-exclude” some bit of the content (!dir/sub/)
  - Multiple .gitignore files are possible  
    nested .gitignore applies only for their children dirs

/**/.terraform - will ignore all .terraform folders anywhere
 or 
.terraform/ - should do the same

/**/*.tfstate - will ignore all .tfstate files anywhere

diff:
  compares changed files with latest snapshot(commit)  
   Changes consist oh hunks:
    https://stackoverflow.com/questions/17995092/what-does-a-hunk-mean-in-relation-to-pushes-on-sourcetree/47431804
  By default compares Working Tree with Staging area
  --staged - compares staged area to latest commit(snapshot)
  --cached - same as --staged
  --check - cheks whitespace issues

   Example:  
  git diff  
   diffs between ALL files in Workig Directory(tree) with staging area  
  git diff --staged  
   diffs between ALL files in Staging area to Last Commit  
  git diff --staged file_name  
   diffs Staging\Last Commit for 'file_name'  
  
  --word-diff - shows diff by words
    I.e. when 1 char changed show only this char, and not whole line
     Example:
    {+--word-diff+}
    Compare branches {+tt+} using [-three-]{+3+} dots ... :
     Where:
    {+<added word>+} with color enabled - green
    [-<removed word-]  - red

  Compare branches using three dots ... :
   Example:
  git diff master...topic-branch
   show difference between topic branch and master 
    in fact with Last commit of topic-branch and first common anscestor
    anscestor is found by `git merge-base topic-branch master`
   Would display same as <branch>...<branch2>
    git checkout topic-branch
    git diff $(git merge-base topic-branch master)
   WOuld display WEIRD stuff:
    git checkout topic-branch
    git diff master
     WILL LOOK LIKE ON MERGE WILL DELETE EVERYTHING UNIQ TO MASTER

difftool:
  same as 'git diff' but executes External diff program
   --tool-help  - shows all available on the system tools for diff

commit message convention:
  Capitalized, short (50 chars or less) summary

  More detailed explanatory text, if necessary. Wrap it to about 72
  characters or so. In some contexts, the first line is treated as the
  subject of an email and the rest of the text as the body. The blank
  line separating the summary from the body is critical (unless you omit
  the body entirely); tools like rebase can get confused if you run the
  two together.
  
  Write your commit message in the imperative: "Fix bug" and not "Fixed bug"
  or "Fixes bug." This convention matches up with commit messages generated
  by commands like git merge and git revert.
  Further paragraphs come after blank lines.
  - Bullet points are okay, too
  - Typically a hyphen or asterisk is used for the bullet, followed by a
  single space, with blank lines in between, but conventions vary here
  - Use a hanging indent

commit:
  creates snapshot(commit) of Staging area, adds it to local repo  
  by default Launches default editor(core.editor) for commit message
   -m/--message=''  - add message w/o core.editor use
   -v/--verbose - verbose display in default editor of diffs committed
   -a/--all - adds all changed or deleted files to staging and commits them
              ignored untracked files though
   --amend  - changes latest commit taking anew stating area and comment
              no new commit is added, but older one updated entirely
              AuthoerDate remains the same
              CommitDate is updated 
              SHA-1 Hash also is CHANGED. 
              DO NOT AMEND __PUSHED__ COMMITS (same as for rebase)
         To add new file to 'amended' commit add it before amend:
           Example:
          git add forgitten_file
          git commit --amend
   --no-edit - When Amended Commit only needs files changed, w/o comment change 
     Example:
    git commit --amend --no-edit

rm: 
  deletes file from git repo (and removes it from Working Tree)
   Params:
  -f - force, when file is staged for deletion and staged w/ new changes after
       then git will ask for -f during git rm execution
  --cached - removes file only from Staging area, leaves it on Working Tree

  Globs:
   git rm log/\*.log    - remove all log files in log dir
    * is escaped so SHELL wont expand it, git will expand it

mv:
  moves (renames) file in git repo
   simple mv old_file new_file; git rm old_file; git add new_file
   would do the same, except in 3 commands
  Example:
   git mv first.txt new_first.txt

log:  
  shows history, in reverse chroinological order - new first
   git log [branch|tag] [params] [[-- ]file_path]
    file_path is always the LAST option
    good practice is precede with '--' to separate for other params
   Params:
  -p/--patch - shows patch of each commit
    Example:
   git log --oneline --patch master..topic
    patch of commits that are not in master but present in topic branch
  -N  - N - number of commits to show
   Example:
  -S <string>  - show commits only where <string> were changed
      See more details in 'Search:' below
    Example:
   git log -S 'rm:' --patch
     only commits where 'rm:' were changed and every commit patch
   git log -p -2  - will show last 2 commits with patch added
  -g [branch]  - shows reflog formatted as git log
  --all - history from all BRANCHES (no detached-head commits shown)
  --show-signature  - display's GPG signature of tar or commit
  --no-merges  - do not show merge-commits 
  --stat  - show stats of each commit, including files changed
         list of files changed, amount of added\removed lines, sum of 
         all files and added\removed lines 
  --pretty=[oneline]  - shows formatted output with different options:
     oneline - show commits as a single lines of hash and comment
     short - multilined: hash, name\email, comment
     full - as it is
     fuller - name\email, dates, comment 
     format:"%h %s"   - formats the log output, with following options:
      %h - short hash
      %s - commit comment
      %G? - G for GOOD signatures, N for NONE, B\U\X\Y\R\E for various BAD ones
      %a - author (there are commiter and author different fields) 
       google other formats
      %cd - committer date
  --oneline - shorthand for --pretty=oneline --abbrev-commit
  --abbrev-commit - shorter commit hashes. 
      7 first chars out of 40 SHA-1 hash
       until they are unambiguous
     SHA-1 collision is less
likely than every member of your programming team being attacked and killed by
wolves in unrelated incidents on the same night.

  --name-only - shows file names for each commit\date\message\auth\email
  --graph  - builds graph of commits, shows branches and merges
          compatible with '--pretty'
    Example:
   git log --pretty=format:"%cd %s" --graph --author-date-order
      will output date of commit, message, and show it as a graph
  --relative-date  - shows '2 weeks ago' instead of real dates
  --since=N.range  - commits since i.e. 2.weeks.ago (from 2 weeks till now)
      .week[s]; .year[s]; .day[s]; .minute[s] - w/o 's' works the same
  --after=N.range  - same as 'since' but vice versa
  --author-date-order - sort BY DATE
  --author <user.name> - show only commits of an author name
  --comitter <user.name> - filter by committer name
  --grep  - grep from commit messages
    Example:
   git log --oneline --author doss- --grep shotts
    show oneline output of commits authored 'doss-' or having 'shotts' in
    the commit message (-m) 
  --all-match - by default --author and --grep will match on OR basis
     and this option will made it AND criteria, so both --author and
     --grep options should match 
   Example:
  git log --author doss- --grep shotts
    will return only commits by 'doss-' AND having 'shotts' in message

 Diff in commits between barnches:
  trunk..branch  - first is trunk, second is trunk with only divergent changes
                   only divergent commits are shown
                   from Branch that are not in whole Trunk
                     commits in Branch starting first common anscestor:
            b - first common anscestor
         a--b--e--f  master is Trunk
             \       :
              c--d   feature is Branch
        master..feature - [D, C] 
        feature..master - [F, E] - feature is 'trunk' now and master is 'branch'
     Example:
    git log origin/master..HEAD
      origin/master is trunk and local HEAD is a divergent branch
   branch1...branch2  - both are branches, shows only commits in those branches
                        common changes from trunk are not shown
            b - first common anscestor
         a--b--e--f  master is Branch1
            |        .
             \       :
              c--d   feature is Branch2
         master...feature [F, E, D, C]
    --left-right
     Example from above:
    < F
    < E
    > D
    > C
 Search:
  git log   could be used    for:
   for finding specific commits by the content of their messages 
   or even the content of the diff they introduce.
  -S  - shows commits where NUMBER OF OCCURANCES changed
        WILL NOT show i.e. variable value change if searched by variable name
  -G  - regex search, WILL SHOW above case
     Example:
    Rake::GemPackageTask.new(spec) do |pkg|
    -    pkg.need_tar = true
    +    pkg.need_tar = false
     $ git log --oneline -S 'need_tar' | wc -l
     >1
       -S shows only initial commit with 'need_tar'
     $ git log --oneline -G 'need_tar' | wc -l
     >2
       -G matches change of line with 'need_tar' but Number of occurances same
  -L <start>,<end>:filename  - search in Lines range
          start\end could be:
          - number - if start\end are numbers, it's absolune, starts from 1
          - regex  - POSIX regex. If start is regex it searches from:
		      start of file or
                      from end of previous -L, if there was any
                      "^/regex/"  - start from beginning of file
                     if End is regex and Start is a number:
                      starts search for regex frim line number from Start 
          - +offset -offset  - useful as <end> relative to <start>
  -L :<funcname>:filename
       searches in the function, which is regex
       from beginning of the <funcname> to next funcname
      Searches from end of previous -L by default
      ^:<funcname> searches from beginning of the file anyway
  -L /regex/,/regex/:filename
       this could do the same as funcname, if git cant handle the func matching
      Example:
     git log -L /^Rake/,'/^end/':Rakefile
      will search inside this function:
       +Rake::GemPackageTask.new(spec) do |pkg|
       +    pkg.need_tar = true
       +end


grep:
  searches through any committed gree, working dir, or even indes(staging)
   Works faster than 'ack' or 'grep'
   Could search in previous commits(and all refspecs, since pointers to commits)
  by regex or a string
  By default searches in files in working directory.
   Params:
  -n\line-number  - shows line number where match was found
  -c\count  - show only filenames and number of matches in each
    Example:
   git grep --count my_func
  -p\show-function  - display context of match (function name of match)
    Example:
   $ git grep -p gmtime_r *.c
   >date.c=static int match_multi(timestamp_t num, char c, const char *date,
   >date.c:   if (gmtime_r(&now, &now_tm)) 
    first output is function signature found by git 
    second line is the match of 'gmtime_r' function
  -e  - next command's parameter is a pattern
        must be used if pattern starts with -
        must be used before patterns in 'and', 'or'
  --and  - logical AND for different patterns to appear on the line to Match
  --or   - logical OR - DEFAULT one 
  --not
  ( ... )  - group, see example below or in git-grep man
     Example:
   git grep --and \( -e 'this' -e that\)
  --heading - show file name before all matches in it
              w/o it there is filename next to Each match
  --break  - print empty line after matches from 1 file
  .... <HASH>  - Git Grep could search in history too
                 Hash could be specified
                 Refspec(commit\tag\HEAD etc) could be specified
    Example:
   $ git grep --break --heading \
      -n -e '#define' --and \( -e LINK -e BUF_MAX \) v1.8.0
   >v1.8.0:builtin/index-pack.c
   >62:#define FLAG_LINK (1u<<20)
   >
   >v1.8.0:cache.h
   >73:#define S_IFGITLINK 0160000
   >74:#define S_ISGITLINK(m)
   >(((m) & S_IFMT) == S_IFGITLINK)
   >
     match line with '#define' AND one of LINK or BUF_MAX matched
     line number is displayed of each matched line
     due to --heading filename on top of matches from it
     due to --break there is empty line after all matches from file 
     Search is done in v1.8.0 tag and NOT in current version of code


remote:
  lists remote handles of the current repo
   Params:
  -v  - verbose, shows URLs for every remote
 add:
  adds a new remote
   Sinopsys:
  <git remote> add <remote_name> <remote_url>
   Example:
  git remote add teamone git://git.team1.ourcompany.com
  git fetch teamone
    this will download all objects & pointers from 'teamone' to be seen locally
   Example:
    when pull from remote1 and push to remote2 (if fork)
   $ git remote add progit https://github.com/progit/progit2.git
   $ git branch --set-upstream-to=progit/master master
   $ git config --local remote.pushDefault origin 
 rename:
   Sinopsys:
  <git remote> rename <remote_old_name> <remote_new_name>
   also changes all remote-tracked branches
    Example:
   git remote rename pb paul
    will change all remote branches from 'pb/master' to 'paul/master'
 remove: rm:
  deletes remote from config
   Sinopsys:
  <git remote> remove <remote_name>
 show:
  showes info about remote
   Sinopsys:
  <git remote> show <remote_name> 
     shows info about remote:
     - branches, tracked or not
       - tracked - good
       - stale - removed on origin, bad. PRUNE THE HERETIC (git remote prune)
     - pull policies - which branch merges with which remote branch
     - push policies - which branch pushes in which remote branch, and current
                       status (up to date, fast forwardable, etc) 
  similar command:
  git ls-remote <remote> - will show different info about remote, with hashes..
 prune:
  removes stale references(branches etc)
  stale - branch deleted on remote but local repo has this ref from remote
   Synopsis:
  <git remote> prune [params] <remote>
   Params:
  --dry-run  - shows what it would do w/o doing it
   Example:
  git remote prune --dry-run origin
   tests what to locally prune for origin remote

ls-remote:
  refspec:
  shows all refspecs in remote, not only refs/heads, which are cloned\fetched
  also shows refs/pull - where pointers to HEAD of REMOTE branch is stored

To get Pull Request as a Branch:
  git ls-remote origin
   cbc221e7de88fa4c796ff11c760e0fb83e78f9bc	refs/pull/1/head
   HEAD's commit hash 				path to HEAD file on REMOTE
						1 is PullRequest #1
  To fetch all refs required to construct WorkTree:
   git fetch origin refs/pull/1/head
    Will download everything required (all commits and other objects)
     Commit Hash of latest commit in PR (its HEAD) will be in REFS_HEAD
   git merge REFS_HEAD
     will merge Pull Request in current branch
  Add ALL pull requests from remote to be downloaded on 'git fetch'
  in .git/config:
  git config -e
  [remote "origin"]
        url = git@github.com:doss-/learning.git
        fetch = +refs/heads/*:refs/remotes/origin/*
   #add:
        fetch = +refs/pull/*:refs/remotes/origin/pr/*
                origin	      local location
                location
       Pull Request Refs are 
       readonly
       updated on every Fetch
   Now possible to Checkout the Pull Request HEAD:
   git checkout pr/1/head

   heads/pull/#/merge
    refspec to merge coummit.
     This would be in GitHub even if Merge is not yet done
     It could be used as a preview of WHAT WOULD BE 
    

show:
  shows detailed info about Commit or Tag
   Example:
  git show ca82a6dff817ec66f44342007202690a93763949
  git show ca82a6d  - will show info about commit
  git show master - will show info about latest commit in master
  git show v0.1  - will show info abotu tag(and commit)
  git show HEAD^  - shows the PARENT of the HEAD commit 
   Same:
   git show HEAD~ - shows FIRST PARENT of the HEAD commit
  git show HEAD^2 - shows the Second Parent of the HEAD
      Useful for MERGE Commits, where:
      1st Parent - branch YOU were on when you merged (i.e. master)
      2nd Parent - branch that was merged (i.e. topic)
  git show HEAD~3 - show 1st parent of 1st parent of 1st parent GRANDPARENT
   Same:
   git show HEAD~~~ - 3 times calls First Parent of a HEAD commit
  git show HEAD~3^2 - show SECOND Parent of Grandparent of HEAD commit
        Variations:
       ~[x]       - x commits back
      HEAD~         - previous commit 
      HEAD~1        - previous commit
      HEAD~~~~~~~~  - 8 commits before
      HEAD~8        - 8 commits before
       ^[1:2]     - First or Second parent
      HEAD^         - previous commit (first parent)
      HEAD^1        - previous commit (first parent)
      HEAD^2        - previous commit (second parent) for MERGE commit
       ~[x]^[1:2] - x commits back First or Second parent
      HEAD~15^2     - Second Parent of 15th commit back(which was merge commit)

   Refspec related:
  git show HEAD@{5} - will show 5th HEAD reference in 'refspec'
  git show master@{yesterday} - will show HEAD of master pointed yesterday
   				only as long as refspec length is
  git show HEAD@{2.months.ago} - same as above
  
rev-parse:
  converts object to SHA-1 hash
   Example:
  dmitry@E203MA:~/learning$ git rev-parse master
  f829f16b706afa1eb29c78e34ca6e99f4cbfbc4d
  dmitry@E203MA:~/learning$ git log --oneline -1
  f829f16 (HEAD -> master, origin/master, origin/HEAD) git_book: part6: refspecs; WebHooks, Services, API :3h

reflog:
  shows history of local HEAD and Branch changes, any changes
  Where local files have pointed for last few months
   Example:
  d7c0e86 HEAD@{3}: commit: git_book: part6: remotes; refspecs :3h
  00180ab HEAD@{4}: commit: PPA repos; LSM, apparmor
  8a39ae0 HEAD@{5}: commit: ansible roles
  f01978f HEAD@{6}: commit: git_book: part6: word-diff :1.5h
  de9e570 HEAD@{7}: commit: git_book: part5: tag; rerere; archive


tag:
  creates tag or lists existing tags.
   Example:
   git tag -a <tag_name> -m 'comment_here' [hash, if not latest commit]
  tags are not Pushed automatically
  -l/--list  - lists existing tags - reqiored when passing wildcarded mask
  git show <tag_name> - will show detailed info about tag and commit
   Example:
  git tag -l "1.1.0?"
    will show only tags matched by the wildcard
  Types:
   - lightweight - pointer to a specific commit(file with commit's checksum)
     To create do NOT pass -a; -s; -m; options
     git show <tagname> - will show only commit info and tagname
      Example:
    git tag <tagname>
      create lighweight commit
    git tag <tagname> <commit_hash>
      will create lightweight tag for some older commit
   - annotated - recommended. have metadata and security checks:
       - tagger name\email
       - tagged date and message
       - checksum
       - could be signed and verificed by GPG GNU Privacy Guard
     Params:
   -a/--annotate  - create annotated tag
   -m/--message <message> - creates message for the tag
    Example:
     git tag -a <tagname>
      creates new annotated tag for latest commit
     git tag -a <tagname> <commit_hash>
      creates new annotated tag for an older commit
   -s  - sign tag with current user key
     Example:
     see 'gpg' here
   -v  - verify signed commit (or tag)
      Example:
     git tag -v v0.1
    GPG need to have signer's public key in its keyring to able to verify
   -u <key id>  - sign tag with specific key
   -n[N]  - prints N lines of tag message
   --contains <commit> - list tags that contains the commit (hash)
    Example:
   git tag -n10 --contains b3584b0
    will list all tags created after this b3584b0 commit
    will print 10 lines of tag's message next to tag name
  Delete tag:
   -d  - delete local tag (no matter on which branch it was created)
   --delete:
   push <remote> --delete - delete remote tag
    Example:
   git tag -d v1.0
     removes local tag
  delete tag #2 - delete remote tag:
   git push remote :refs/tags/v1.0
    this pushes Null instead of tag - null is on the left of ':'
  Checkout && Detached Head:
   Checkout tag:
  git checkout v1.0
   will checkout code up to tag but in DETACHED HEAD
   commit if done would be reachable only by hash
  Recommended checkout tag:
   checkout into new branch:
    git checkout -b Branch-Name v0.1
   creates new branch from the tag, commits done would go into the branch

alias:
  creates alias for git command and params
   git config [--global] alias.<name> 'command'
    Example:
   git config --global alias.unstage 'reset HEAD --'
    now 'git unstage File.txt' instead of 'git reset HEAD -- File.txt'
   git config alias.last 'log -1 HEAD'
    alias 'last' to show last commit
  !Extrnal aliases
    to alias external command prefix it with !
     Example:
    git config alias.testt '!echo "test line"'
     now 'git testt' will output 'test line'

stash:
  saves working tree and staging(index) into a pocket, making working 
  directory clean.
  could have multiple entries, saved as a refspec (places where HEAD previously
  pinted)
 push: 
  default, saves all current changes into pseudo-commit
  --keep-index  - stashes all changes, but cleans only working tree
  -u/include-untracked - adds Untracked files to the stash
  -a/all  - adds all files, even including IGNORED files
  -p/patch - interactive mode(only for Tracked files)
 list:
  lists all saved stashes, looks like git reflog
 show:
  shows short Status of stash, first by default (indexing starts from 0)
  Does NOT shows if have Untracked files (could return no lines if only 
  untracked files in stash)
  by specifiying refspec of stash history could list other stashes
    Example:
   git stash show stash@{2}
    will show third stash
 apply:
  applies changes from stash to a working tree by default
  If working tree is not clean, git tries to merge (merge conflicts possible)
  Stash remains in reflog
  --index - saves Staging state from stash, if something was staged
    Example:
   git stash apply --index stash@{2}
  drop:
   remove stash from reflog, removes first by default
     Example:
    git stash drop stash@{2}
     remove 3rd stash from stash history
  pop:
   apply and drop commands together
     Example:
    git stash pop stash@{2} 
  branch:
   creates a new branch for you with your selected branch name, checks out 
   the commit you were on when you stashed your work, reapplies your work 
   there, and then drops the stash if it applies successfully
    Example:
   git stash branch MY-NEW-BRANCH

clean:
  it seems removes only Untracked files
  Or Untracked + Ignored.
  DOes not touch Edited files, so stash is simply better
   Except the case of need to remove bunch of garbage(or generated) files
   Safer: git stash --all  - which would clean tree but save it
  Require Force:
    clean.requireForce
    git config --global --add clean.requireForce true
   prefents clean without Force given
  -f  - Force 
  -f -f  - delete untracked nested dirs with .git inside them (repositories)
  -n/dry-run - dry run
    Run either with -n or -f
    First -n; Then -f;
  -d  - remove untracked directories
  -x  - remove ignored files
  -i  - interactive mode
  
  

checkout:
  switch branches or restore working tree files
   Synopsys:
  git checkout [params] [[--] filename]
   Params:
  -b <new-branch> - switch to the newly created branch
    creates new branch based on current HEAD
  -b <new-branch> <based-on-branch>
    Example:
  git checkout -b new-branch origin/master
    creates new branch based on given branch (origin/master)
   Remote branch tracking
   By default git does not track remote branches except Master
  -p/patch  - interactive restore of working tree file (see git add -i)
   To manually start tracking branches do:
  --track
    Example:
   git checkout --track origin/another-branch
    Under the hood it creates local branch pointed to remote one:
   git checkout -b another-branch origin\another-branch
   git checkout -b my-local-branch origin\branch-i-want-to-track
    Untracked remote branches, that are DELETED on remote are STALE
    to delete those:
    git remote prune [--dry-run] origin
   git checkout another-branch
    will also create a tracking, shorthand for --track, if:
    - branch for checkout does not exist locally
    - exactly matches the name on only one remote
   Vice-versa (when need to point local branch to track some remote one):
   git branch -u origin/another-branch

branch:
  shows branches, creates branches
   Create branch:
  git branch new-branch
   Params:
  -a/--all - shows all local branches and * next to current
  -d/--delete - deletes branch locally
      will fail to delete unmerged branches (those from --no-merged)
  -f/--force - force, i.e. to delete not merged in current branch
  -D - force deletion (--delete + --force)
  -v - shows latest commits of all known branches
  -vv - shows all remotely tracked branches (and latest commits)
  --merged [branch|commit] - shows branches merged in current branch
        basically other than * branches could be deleted
        with [branch] will show info as if HEAD is in that branch
        if [commit] given - shows branches that DO have this commit
     PRUNE remote merged branches, which are NOT tracked and STALE
  --no-merged [branch|commit] - shows branches NOT merged in current branch
        with [branch] will show info as if HEAD is in that branch
        if [commit] given - shows branches that DO NOT have this commit
  -u/--set-upstream-to <upstream> - points local branch to track remote one
                   'git pull' will work param-less then
    Example:
   git branch -u origin/serverfix
    will set track between current and 'serverfix' branches for parameterless
    pulls

apply:
  applies patches sent by email
   also can handle added, deleted and renamed files from patch
   Could apply patches generated by `diff` command (not git diff)
   Should be used for legacy patches, other is done by `git am`
  Applies whole patch or done, not in-betweens.
   Params:
  --check - like dry run
   Example:
  $ git apply --check 0001-see-if-this-helps-the-gem.patch
   Return 0 and nothing in stdout if OK
   Returns 1 and erros in stdout(err?) if not applies cleanly

am:
  like `git apply` but works with `git format-patch` generated patches
   Stands for: 'apply a series of patches from a mailbox'
   originally was reading 'mbox' format fies (concat emails into 1 file)
    Params:
  -3 - try 3 way merge (of parent of patch's commit is in local repo)
  --resolved - use when patch merge conflicts were manually fixed

merge vs rebase:
 https://www.youtube.com/watch?v=CRlGDDprdOQ
  Rebase overides commits. But rebase local topic branch on latest commit
 of master, makes master merge then topic branch by fast forward.
  Rebase have cleaner history w/o merge commits(fast-forward == no conflicts
 == no merge commits; anything other has merge commit) thus easier to read,
 and logical.
 REBASE LOCAL BRANCH BEFORE MERGE.
 NEVER REBASE WHAT IS PUBLIC. If did - others need git merge --rebase.
 But still suck.

merge:
   merges branches
   if can Fast Forward (where there is just consequental commits w/o divergent)
   will NOT create merge commit
  If automerged then it will merge and create mergecommit with resulting work
  When conflicts, manual merge required, resulting in merge commit
  does 3 way merge of two branches:
   two latest commits of each branch
   creates new commit based on merge of those commits
   new commit goes into main branch(where other branch was merging)
  <branch_to_merge_into_current> - merges given branch into current
    will be executed after fetch in pull, when it will merge fetched
    branch origin/<current_tracked> into current branch
   Example:
   git merge topic   - will merge topic into current branch
  --abort - aborts started merge that ended with conflicts
  --verify-signatures - reject commits signed with not Truested GPG 
    Will fail to merge commits Not Signed or Signature is Not Valid
   -S  - sign the resulting merge commit too

merge-base:
  finds the original? base of branch, returns hash of the base commit

rebase:
  changes base of current(or given) branch to another branch or commit
  !! Rewrites commits - creates new commit(new hash) with the same contents
  like date, commetter, comment etc.
   Does checkout on <branch> first (if given) , if not uses HEAD
   then compares to <upstream> branch
    if --onto given - compares between <newbase> and <branch>(HEAD)
   Params:
  --onto <newbase> - starting point at which to create new commits
         if not set, starting point would be <upstream>
         When there is Another branch between source and target
     Example:
            o---o---o---o---o  master
                    \
                     o---o---o---o---o  next
                                      \
                                       o---o---o  topic
      git rebase --onto master next topic
        Outcome:
            o---o---o---o---o  master
                   |            \
                   |             o'--o'--o'  topic
                    \
                     o---o---o---o---o  next
  <upstream> - branch to compare against
  <branch>  - working branch, default is HEAD
   Example:
  E---F---G---H---I---J  topicA
  git rebase --onto topicA~5 topicA~3 topicA
  E---H'---I'---J'  topicA
   Where:
   --onto: start new commits from topicA~5 - commit 'J'
   compare with 'H'
   on given branch 'topicA'
    For some reason it:
     leaves E in place - first commit?
     ignores F and G - related to all be in same branch?
  --continue
     go on with rebase, after conflicts resolved (edit and 'add' to staging) 
             #########
             ## INTERACTIVE
             ########
         Edit previous commits (not latest
           DO IT ONLY LOCALLY
  -i  - interactive if 'EDIT' instead of 'PICK' next to commit from range
         See all commands (pick, edit etc) in text editor's commented section
     Example:
    git rebase -i HEAD~3
        OUTPUT:
         >pick f7f3f6d Change my name a bit
         >pick 310154e Update README formatting and add blame
         >pick a5f4a0d Add cat-file
      will take commits between HEAD and HEAD~3 and rebase onto 4th commit
      from current HEAD (HEAD - 3 commits would be replayed on 4th commit)
       Each of those commits could be EDITED(amended) - patch and comment
     Check which commits:
      git log --pretty=format:"%h %s" HEAD~3..HEAD
       Notice '..' and not '...'
     In editor after 'rebase -i HEAD~3' displayed list of commits
      in reverse to 'git log' order (cause it is replayin oldest change first)
     'pick' - only replay
     'edit' - stop at this commit and edit
        Example:
         >edit f7f3f6d Change my name a bit
       then change and add to staging and 'git commit --amend' 
       then 'rebase --continue'
           Change Order Of Commits
            OR
           Remove commits entirely
      git rebase -i HEAD~3
       In opened window REMOVE lines for commits you want to remove
                        CHANGE order of commits 
                     or EDIT commits
        Example(Consider example of lines above as original):
         >pick a5f4a0d Add cat-file
         >pick f7f3f6d Change my name a bit
    310154e commit was removed
    a5f4a0d commit become parend of f7f3f6d, but was it's grandchild originally 
     If save the editor file , AND resolve conflicts if any (and 'git add')
      then 'git rebase --continue'
     Commits rewritten, commits removed, new history is made.
     DO NOT APPLY TO PUSHED COMMITS
   Squash:
     Squash all NEWER commits , on top of 1 oldest one
         >pick f7f3f6d Change my name a bit   # parent commit
         >squash 310154e Update README formatting and add blame   #child commit
         >squash a5f4a0d Add cat-file         # grand child commit
      <Save editor>
         Enter commit message (merged from squashed commits) in new editor
      <Save editor>
         commits are overriden
   Split commits:
     This is kind of a hack:
      Say given 3 commits; 
      And wanna split second (310154e)
        $ git rebase -i HEAD~3
         >pick f7f3f6d Change my name a bit
         >edit 310154e Update README formatting and add blame
         >pick a5f4a0d Add cat-file
         :wq
          #Git applies first(f7f3f6d) commit as is; then:
        $ git reset HEAD^   # reset --mixed to Previous(f7f3f6d) 
                            # Staging(conents of 310154e) overides Working Tree
        $ git add README    # part of 310154e
        $ git commit -m 'Update README formattint'
        $ git add lib/simplegit.rb  # second part of 310154e
        $ git commit -m 'Add blame
        $ git rebase --continue     # apply a5f4a0d commit 
          # Will end up with 4 commits:
        $ git log -4 --pretty=format:"%h %s"
        1c002dd Add cat-file              # Re-written old commit
                                          #  (HASH, Commit Date)
        9b29157 Add blame                 # New commit
        35cfb2b Update README formatting  # New commit
        f3cc40e Change my name a bit      # Re-written old commit 
                                          #  (HASH, Commit Date)


filter-branch:
  nuclear
  History-rewrite tool for Large numer of Commits.
   In a scriptable way.
  
  --tree-filter:
   Remove file from Every commit (i.e. passwords.txt committed)
  $ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
     Will run given command - rm -f passwords.txt - on every snapshot(commit)
     And recommit the result (as a new commit supposedly)
      Try it on test branch first(or better clone the repo, to be sure)
  --all  - run on all branches
  --subdirectory-filter:
   Subdirectory as a New Root
    When IMPORT FROM ANOTHER Source Control (VCS)
  $ git filter-branch --subdirectory-filter trunk HEAD
     Will do 'trunk' subdirectory as new Root
  --commit-filter:
   Change email address globally
    To change ONLY YOURS email addresses, AND NOT OTHERS:
  $ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
          GIT_AUTHOR_NAME="Scott Chacon";
          GIT_AUTHOR_EMAIL="schacon@example.com";
          git commit-tree "$@";
        else
          git commit-tree "$@";
        fi' HEAD
   NOTE: Because commits contain the SHA-1 values of their parents, this command
         changes every commit SHA-1 in your history, not just those that have 
         the matching email address.
   

rerere:
  REuse REcorded REsolution
  When rerere is enabled, Git will keep a set of pre- and post-images from 
  successful merges, and if it notices that there’s a conflict that looks 
  exactly like one you’ve already fixed, it’ll just use the fix from last time
   Config:
  rerere.enabled  - turn on in config
    Example:
   git config [--global] rerere.enabled true
  
  Creates database of all resolved conflicts. 
   git rerere   - will go through the db of conflicts and resolve current
                  if same resolve found in DB. Default if enabled in config
   Could preview what would be resolved
   Could remove specific conflict resolutions
   Could clear whole db of resolutions

hash-object:
 gpg:
  tool for signing and encryption
  It could store list of keys. 
  Keys could sign Tags.
  Public key could be saved as a Blob into repository.
   Example:
  $ gpg --list-keys
  > pub 1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
  $ gpg -a --export F721C45A | git hash-object -w --stdin
  > 659ef797d181633c87ec71ac3f9ba29fe5775b92
    will show and pipe public key into git DB as a blob object returning hash
  $ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92
  $ git push tags
    the key is in public repo now
   To get the key:
  $ git show maintainer-pgp-pub | gpg --import
    Include instructions in tag's message (tag -m '<here>') to provide readme
  Sign tags:
    Example:
   git config user.signingkey EA17397DA3ED365A8C2CD3E230194F56DD6B037A
   git tag -s 'v1.5' -m 'my signed 1.5 tag'
  Sign commits (1.79+ git version):
   commit -S  - sign commit
    Example:
   git commit -S -m 'signed commit'
  log --show-signature  - shows signatures for tag and commit in git log
   

describe:
  generates human readable name for object
  latest tag + number of commits since till given hash + g + hash
  g - means git
    Example:
   $ git describe master
   v1.6.2-rc1-20-g8c5b85c
    Where:
   v.1.6.2-rc1 - tag name
   20 commits before master (hash is passed to describe under-the-hood)
   g - git
   8c5b85c  - hash of 'master' branch - the given commit
  --tags  - to use NOT annotanet tags
     uses Annotated tags only by default


Release
archive:
  archives current tree(snapshot) into stream which could be saved into archive
    tar.gz example:
  git archive master --prefix='project/' | gzip > `git describe master`.tar.gz
   sames directory 'project' with all git repo in it into tar.gz
    zip Example:
  git archive master --prefix='prjct/' --format=zip > `git describe master`.zip 


shortlog:
  generates short log of commit messages since given commit for given branch
   Example:
  git shortlog --no-merges master --not v1.0.1
   will show list of commit messages (except merges) for 'master' branch
   since 'v1.0.1' tag. Grouped by user.

GitHub:
 Labs \ learning:
  https://lab.github.com/
 https://developer.github.com
  Hooks:
    Push notification via HTTP POST request about what happening on repo
    Triggered at Events, lots of them. Push event - on 'git push' into repo
    Could have JSON or other Payload
    Developer console for debug in Hook declaration space(page)
  Services:
    Push notification via Email or lots of other integrations (CI, tracker etc)
  API:
    Incoming notifications and Manipulations TO github
    Has lots of different API ENDPOINTS(methods)
     i've added it to only remember correct name of a call - Endpoint
   Example:
    curl https://api.github.com/users/doss-
     will return info about 'doss-' user in JSON format
     and other API Endpoints to related to profile
    Authenticated user could do 5000 requests per hour
    Guest user could do 60 requests per hour(once a minute kind of)
   Comment on an issue:
    Endpoint address:
     repos/<user>/<repo>/issues/<num>/comments
    Example: with tokenized Auth
     curl -H "Content-Type: application/json" \
        -H "Authorization: token TOKEN" \
        --data '{"body":"A new comment, :+1:"}' \
        https://api.github.com/repos/schacon/blink/issues/6/comments
    Example: change commit status in WebHook Handler using API:
     detailed: see gitbook 
      https://git-scm.com/book/en/v2/GitHub-Scripting-GitHub
     Ruby:
      push = JSON.parse(request.body.read) # parse the JSON
      repo_name = push['repository']['full_name']
        ...
      push["commits"].each do |commit|
          ...
        sha = commit["id"]
      status_url = "https://api.github.com/repos/#{repo_name}/statuses/#{sha}"
        ...
      HTTParty.post(status_url,
        :body => status.to_json,
        :headers => {
          'Content-Type'  => 'application/json',
          'User-Agent'    => 'tonychacon/signoff',
          'Authorization' => "token #{ENV['TOKEN']}" } 
      }


