# What is Kubernetes
System for running many diffent types and different numbers of  containers over multiple different machines (PC or VM).

- It could run different images of the containers
- It could run containers on different machines (if it is the Node)

# Why use Kubernetes
To scale up containers on different machines in different quantities.

- Only specified containers could be scaled.
- Different containers could scale at different numbers.

# Short summary

![takeaways](img/k8s_imprt_takeaways.jpg)

# Production and Dev environments difference

# Kubectl

## Install
https://kubernetes.io/docs/tasks/tools/install-kubectl/#install-kubectl-on-linux

1. download and add executable: 
``` 
curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt` /bin/linux/amd64/kubectl 
chmod +x ./kubectl
```
2. add into Path
```
echo $PATH
sudo mv ./kubectl /usr/local/bin/kubectl
```

3. test
```
kubectl version --client
```

### Autocompletion

1. check bash autocompletion installed and monitors completion dir
```
apt list --installed | grep completion
OR
yum list installed | grep completion

grep '/etc/bash_completion.d' /usr/share/bash-completion/bash_completion
```
2. Write kubectl completion into common dir
```
sudo su -
kubectl completion bash >/etc/bash_completion.d/kubectl
```
3. Reopen terminal, relogin or re-source .bashrc
```
. ~/.bashrc
```

## Overal Architecture

- Master
- Node
- - Pod 
- - - Container

![image](img/k8s_VM_by_Minikube_overall.jpg)
![image](img/k8s_VM_by_Minikube_detailed.jpg)



## API versions in Config(`.yaml`) files

Different versions support different predefined sets of Objects available to use out of the box.  
Presumably those could be extended at custom level.

### v1:
includes at least following types:
- componentStatus
- configMap
- Endpoints
- Event
- Namespace
- Pod

### apps/v1
includes at least following types:
- ControllerRevision
- StatefulSet

## Objects (`kind:`)

Kubernetes operates objects.  
Kubernetes cluster contains of Objects of different types.  
Config file(`.yaml`) is required for each object.  
Object represents either container or entity required for container - like Port mapping.  
Objects are running inside a Kubernetes Node.  

### Pod

Type of Objects that runs containers.  
Pod could have more than 1 container running in it.  
Pod is like a Package with binaries - smallest deployable thing. Which means only vital containers need to be inside (like only vital binaries need to be in a package, and other binaries go to other packages).

Example:
```
apiVersion: v1
kind: Pod
metadata:
    name: client-pod
    labels:
        component: web
spec:
    containers:
        - name: client
          image: stephengrider/multi-client
          ports: 
            - containerPort: 3000
```

### Deployment
Production grade `pod`; kind of.
Runs set (1+) of identical `pods`(which usually run 1 container or more but really close related). Controls the heals of `pods` and resarts if necessary.  
Basically `Deployment` objects are little `masters` to the `Pods` they create. Like `master` governs all the `Objects` in Kubernetes.

#### Deployments vs Pods

![deployment_vs_pods](img/k8s_pod_vs_deployment.jpg)

#### Pod Template

Every deployment has a `Pod Template` which is a patter on how to create Pods from this Deployment in the future.

![deployment_details](img/k8s_deployment_details.jpg)


### Service
Types of Objects that are related to networking setup.

#### ClusterIP

#### NodePort

NOTE: ONly good in development setup!!  

Port mapping for Pods.   
Key values inside `selector:` yaml node here are the links to which exact Pod(or other Object i believe) should be these options be applied to.  
Example:
```
apiVersion: v1
kind: Service
metadata:
    name: client-node-port
spec:
    type: NodePort
    ports:
        - port: 3050
          targetPort: 3000
          nodePort: 31515
    selector:
        component: web
```
When NodePort object boot up it will look into `selector:` , get `component: web` and look for Objects which have same key-value.  
And Object(Pod) with name 'client-pod' will have same key-value pair - `component: web`. Then port mapping from Service::NodePort will be applied to the Pod with 'client-pod' name.  
`component` is key but is not a keyword and coud be _any string_.
`web` is value but could also be _any string_.

Ports:  

NodePort is the layer through which all communication to Pod is moving.
If any other Pod wants to communicate to the Pod it will go through NodePort which describes port info for particular `selector`:  
![NodePort_Ports](img/k8s_NodePort_Ports.jpg)

- port  
port number at which other Pods going to contact NodePort to send traffic to `targetPort`
- targetPort  
port number at which NodePort will send traffic to (the one target Pod expects)
- nodePort (__range: 30000 - 32767__)  
port number at wchich NodePort is being accessed by the Browser. NodePort kind of become a 'target Pod` here.

#### LoadBalancer

#### Ingress

### ReplicaController

### StatefulSet



## CLI Commands

### apply:
Changes current configuration of the Cluster - thus changing the 'Desired state'  
Master will start to work onto bringing 'Actual state' to 'Desired state'  

![Apply command structure](img/k8s_Apply_struct.jpg)

>NOTE:  
Only some fields of config file could be updated through `apply`.  
_The Pod "client-pod" is invalid: spec: Forbidden: pod updates may not change fields other than `spec.containers[*].image`, `spec.initContainers[*].image`, `spec.activeDeadlineSeconds` or `spec.tolerations` (only additions to existing tolerations)_


### cluster-info:
check cluster info
 
Expect output:
>Kubernetes master is running at https://192.168.99.100:8443  
KubeDNS is running at https://192.168.99.100:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy


### get:
prints status of group of object types (i.e. `pods`)

> NOTE:  
`pods` is same as `pod` and probably all other plural\single stuff.  
Same applies probably to all other commands and types(kinds).

To get list of pods:
![get_pods](img/k8s_get_pods_struct.jpg)

Expected output:
```
dos:simplek8s$ kubectl get pods
NAME         READY   STATUS    RESTARTS   AGE
client-pod   1/1     Running   0          25s
```
Where `READY`: \<number of running pods\>/\<number of desired pods to run\>

To get list of Services:
```
dos:simplek8s$ kubectl get services
NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
client-node-port   NodePort    10.102.55.176   <none>        3050:31515/TCP   4m13s
kubernetes         ClusterIP   10.96.0.1       <none>        443/TCP          2d22h
```
`kubernetes` is kind of system service, could ignore that for now  
`PORT` [column](#nodeport) lists both `port` and `nodePort` properties

### describe:

describes a particular object

![describe](img/k8s_describe_struct.jpg)

To get info about a pod with a name:
```
dos:simplek8s$ kubectl get pod
NAME         READY   STATUS    RESTARTS   AGE
client-pod   1/1     Running   2          25h
dos:simplek8s$ kubectl describe pods client-pod | grep -i image:
    Image:          stephengrider/multi-worker
```

# Minicube

## Install

1. check virtualization is turned on
```
grep -E --color 'vmx|svm' /proc/cpuinfo
```

2. download and add executable:
```
curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \
  && chmod +x minikube
```
3. install (copy into path dir)
```
sudo mkdir -p /usr/local/bin/
sudo install minikube /usr/local/bin/
```

4. check version
```
minikube version
```

5. pick driver and start  
Virtual box is default driver; full list of drivers: https://kubernetes.io/docs/setup/learning-environment/minikube/#specifying-the-vm-driver  
Usually drivers require installation, like one for `kvm2`
```
minikube start --driver=virtualbox
minikube status
```

6. stop minikube
```
minikube stop
```

## CLI Comands

### start
starts minikube and 1 VM

### ip
shows ip of that one VM